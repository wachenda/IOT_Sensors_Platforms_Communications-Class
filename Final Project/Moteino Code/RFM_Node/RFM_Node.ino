// Modified by David Wachenschwanz
// Based on Sample RFM69 sender/node sketch for the MotionMote
// http://lowpowerlab.com/motionmote
// PIR motion sensor connected to D3 (INT1)
// When RISE happens on D3, the sketch transmits a "MOTION" msg to receiver Moteino and goes back to sleep
// In sleep mode, Moteino + PIR motion sensor use about ~60uA
// IMPORTANT: adjust the settings in the configuration section below !!!

// **********************************************************************************
// Copyright Felix Rusu of LowPowerLab.com, 2016
// RFM69 library and sample code by Felix Rusu - lowpowerlab.com/contact
// **********************************************************************************
// License
// **********************************************************************************
// This program is free software; you can redistribute it 
// and/or modify it under the terms of the GNU General    
// Public License as published by the Free Software       
// Foundation; either version 3 of the License, or        
// (at your option) any later version.                    
//                                                        
// This program is distributed in the hope that it will   
// be useful, but WITHOUT ANY WARRANTY; without even the  e
// implied warranty of MERCHANTABILITY or FITNESS FOR A   
// PARTICULAR PURPOSE. See the GNU General Public        
// License for more details.                              
//                                                        
// You should have received a copy of the GNU General    
// Public License along with this program.
// If not, see <http://www.gnu.org/licenses/>.
//                                                        
// Licence can be viewed at                               
// http://www.gnu.org/licenses/gpl-3.0.txt
//
// Please maintain this license information along with authorship
// and copyright notices in any redistribution of this code
// **********************************************************************************

// Depending on the type of data (integer, float or string) one of the payload variables is used
// Command = 0 means write a value in the node, cmd = 1 means read a value 
//
// Current defined devices are:
//
//  0 uptime:     read uptime node in minutes
//  1 node:     read/set transmission interval in seconds, 0 means no periodic transmission
//  2 RSSI:     read radio signal strength
//  3 Version:    read version node software
//  4 voltage:    read battery level
//  5 ACK:      read/set acknowledge message after a 'set' request
//  6 toggle:     read/set toggle function on button press
//  7 timer:      read/set activation timer after button press in seconds, 0 means no timer
//  8 Garage Opener
//  9 retry:      read number of retransmissions needed in radiolink//  
//  16  actuator:   read/set LED or relay output
//  40  Button:     tx only: message sent when button pressed
//  48  temperature:    read temperature
//  49  humidity:   read humidity
//  50  pressure:    read pressure
//  51  temperature:    OneWire Sensor
//  63  Light Level:    level in DAC's of light level
//  64  garage button: pulse garage relay
//  72  string:     
//  90  error:      tx only: error message if no wireless connection (generated by gateway)
//  92  error:      tx only: device not supported
//  98  ID:         64-bit unique ID from OneWire DS18S20
//  99  wakeup:     tx only: first message sent on node startup
//
#define VERSION "RFM_MailBox_rev09092016"        // this value can be queried as device 3


#include <RFM69.h>    //get it here: https://www.github.com/lowpowerlab/rfm69
#include <RFM69_ATC.h>//get it here: https://www.github.com/lowpowerlab/rfm69
#include <SPI.h>      //comes with Arduino IDE (www.arduino.cc)
#include <LowPower.h> //get library from: https://github.com/lowpowerlab/lowpower
                      //writeup here: http://www.rocketscream.com/blog/2011/07/04/lightweight-low-power-arduino-library/
#include <SPIFlash.h> //get it here: https://www.github.com/lowpowerlab/spiflash
#include <Wire.h>     //comes with Arduino
#include "BME280.h"

//#define SERIAL_EN             //comment this out when deploying to an installed Mote to save a few KB of sketch size
#include "debug.h"
#include "config.h"
#include "LightLevel.h"
#include "Battery.h"

//*********************************************************************************************
//************ IMPORTANT SETTINGS - YOU MUST CHANGE/CONFIGURE TO FIT YOUR HARDWARE *************
//*********************************************************************************************
//Match frequency to the hardware version of the radio on your Moteino (uncomment one):
//#define FREQUENCY     RF69_433MHZ
//#define FREQUENCY     RF69_868MHZ
#define FREQUENCY     RF69_915MHZ
#define IS_RFM69HW    //uncomment only for RFM69HW! Remove/comment if you have RFM69W!
//#define ENABLE_ATC    //comment out this line to disable AUTO TRANSMISSION CONTROL
#define ATC_RSSI      -75
#define ENABLE_BME280 //uncomment to allow reading the BME280 (if present)
//*********************************************************************************************

#define MOTION_PIN     3  // D3
#define MOTION_IRQ     1  // hardware interrupt 1 (D3) - where motion sensors OUTput is connected, this will generate an interrupt every time there is MOTION
#ifdef ENABLE_ATC
    RFM69_ATC radio;
#else
    RFM69 radio;
#endif

#define FLASH_SS      8 // and FLASH SS on D8 on regular Moteinos (D23 on MoteinoMEGA)
SPIFlash flash(FLASH_SS, 0xEF30); //EF30 for 4mbit  Windbond chip (W25X40CL)

BME bme;    // BME280 

volatile boolean motionDetected=false;

typedef struct {          // Radio packet format
    int nodeID;           // node identifier
    int devID;            // device identifier 
    int cmd;            // read or write
    long  intVal;           // integer payload
    float fltVal;           // floating payload
    char  payLoad[32];          // string payload
} Message;

Message mes;

long  TXinterval = 60;        // periodic transmission interval in seconds, if 0, no periodic transmission
long  TIMinterval = 10;       // timer interval in seconds
bool  toggleOnButton = true;        // toggle output on button press
int ACT1State;          // status ACT1 output

int signalStrength;         // radio signal strength
bool  setAck = false;         // send ACK message on 'SET' request

bool send[100] = {false};

bool  send0, send1, send2, send3, send4;
bool  send5, send6, send7, send8, send9;
bool  send16,  send40, send48, send49, send50, send51, send63, send72, send92;   // message triggers
bool  promiscuousMode = false;      // only listen to nodes within the closed network
bool  wakeUp = true;          // wakeup flag
bool  curState = true;        // current button state
bool  lastState = true;       // last button state
bool  retx = true;          // flag to signal retransmission
int numtx;              // number of retransmissions

void motionIRQ(void);
bool receiveData();
void parseCmd();
void sendMsg();

void setup() 
{
    DEBUGInit(SERIAL_BAUD);

    Get_Node_Config();
    
    radio.initialize(FREQUENCY,node.NODEID,node.NETWORKID);
    char buff[50];
    sprintf(buff, "\nTransmitting at %d Mhz...", FREQUENCY==RF69_433MHZ ? 433 : FREQUENCY==RF69_868MHZ ? 868 : 915);
    DEBUGln(buff);
    #ifdef IS_RFM69HW
        radio.setHighPower(); //uncomment only for RFM69HW!
    #endif
    radio.encrypt(node.ENCRYPTKEY);
    radio.promiscuous(promiscuousMode);     // only listen to closed network

    //Auto Transmission Control - dials down transmit power to save battery (-100 is the noise floor, -90 is still pretty good)
    //For indoor nodes that are pretty static and at pretty stable temperatures (like a MotionMote) -90dBm is quite safe
    //For more variable nodes that can expect to move or experience larger temp drifts a lower margin like -70 to -80 would probably be better
    //Always test your ATC mote in the edge cases in your own environment to ensure ATC will perform as you expect
    #ifdef ENABLE_ATC
        radio.enableAutoPower(ATC_RSSI);
        DEBUGln("RFM69_ATC Enabled (Auto Transmission Control)\n");
    #else
        DEBUGln("RFM69_ATC Not Enabled\n");
    #endif
  
    pinMode(MOTION_PIN, INPUT);
    attachInterrupt(MOTION_IRQ, motionIRQ, RISING);

    if (flash.initialize()) 
    { 
        DEBUGln("Flash Initialized and put in sleep mode\n");
        flash.sleep(); //if Moteino has FLASH-MEM, make sure it sleeps
    }

    #ifdef ENABLE_BME280
        bme.settings.commInterface = I2C_MODE;
        bme.settings.I2CAddress = 0x77;
        bme.settings.runMode = 2; //Forced mode
        bme.settings.tStandby = 0;
        bme.settings.filter = 0;
        bme.settings.tempOverSample = 1;
        bme.settings.pressOverSample = 1;
        bme.settings.humidOverSample = 1;
        if (!bme.begin()) 
        {
            DEBUGln("Could not find a valid BME280 sensor, check wiring!");
            while (1);
        }
    #endif
}


bool fPresence = false;

void motionIRQ()
{
  motionDetected=true;
}

void loop() 
{
    static uint32_t lastIRQtime;
    static uint32_t time=0, now=0, MLO=0, BLO=0;

    now = millis();

    DEBUG("lastIRQtime = "); DEBUGln(lastIRQtime);
    DEBUG("time = "); DEBUGln(time);
    DEBUGln(time - lastIRQtime);
    DEBUGln();
    
    if(fPresence && time - lastIRQtime > node.MOTION_DUPLICATE_INTERVAL)
    {
        fPresence = false;
        DEBUGln("Presence Detection Timed Out");
        send[40] = true; // Presence
        send40 = true;  //  Presence
        sendMsg();
        radio.sleep();
    }

    if(motionDetected)
    {
        lastIRQtime = time;
        DEBUGln("IRQ");
        motionDetected = false;
        if(!fPresence)
        {
            fPresence = true;
            DEBUGln("Motion Detected");
            send[40] = true;
            send40 = true;  // Motion Detected
            sendMsg();
            radio.sleep();
        }
    } 

    if(time-BLO > node.UPDATE_INTERVAL || wakeUp)
    {
        send[4] = true;     // voltage level
        send[40] = true;    // Presence 
        send[48] = true;    // Temperature
        send[49] = true;    // Humidity
        send[50] = true;    // Pressure
        
        
        //        send2 = true;   // signal strength
        send4 = true;   // voltage level
        send40 = true;  // Presence Detected
        #ifdef ENABLE_BME280
                send48 = true;          // send temperature
                send49 = true;          // send humidity
                send50 = true;          // send pressure  
        #endif
        #ifdef ENABLE_LIGHT_LEVEL
            send63 = true;
            send[63] = true;
        #endif
        BLO = time;
        DEBUGln("Battery Time-out");
        sendMsg();      // send any radio messages
        DEBUGln("Done sending in battery time-out");
        radio.sleep();
    }
    DEBUGFlush();

    time += millis()-now;
    radio.sleep();
    LowPower.powerDown(SLEEP_8S, ADC_OFF, BOD_OFF);
    DEBUG("WAKEUP8s ");
    time += 8000;
    DEBUGln(time);
}



//
//========    RECEIVEDATA : receive data from gateway over radio
//
bool receiveData() 
{
    bool validPacket = false;
    if (radio.receiveDone())        // check for received packets
    {
        if (radio.DATALEN != sizeof(mes))     // wrong message size means trouble
        {
            DEBUGln("invalid message structure..");
        }
        else
        {
            mes = *(Message*)radio.DATA;
            validPacket = true;       // YES, we have a packet !
            signalStrength = radio.RSSI;
            DEBUG(mes.devID);
            DEBUG(", ");
            DEBUG(mes.cmd);
            DEBUG(", ");
            DEBUG(mes.intVal);
            DEBUG(", ");
            DEBUG(mes.fltVal);
            DEBUG(", RSSI= ");
            DEBUGln(radio.RSSI);
            DEBUG("Node: ");
            DEBUGln(mes.nodeID);
        }
    }
    if (radio.ACKRequested()) radio.sendACK();    // respond to any ACK request
    return validPacket;         // return code indicates packet received
}   // end recieveData


//
//==============    PARSECMD: analyse messages and execute commands received from gateway
//
//--------------            parse messages received from the gateway
void parseCmd() {         
    send0 = false;            // initialise all send triggers
    send1 = false;
    send2 = false;
    send3 = false; 
    send4 = false;
    send5 = false;
    send6 = false;
    send7 = false;
    send8 = false;
    send9 = false;
    send16 = false;
    send40 = false;
    send48 = false;
    send49 = false;
    send50 = false;
    send51 = false;
    send63 = false;
//    send64 = false;
    send92 = false;

    memset(&send, false, sizeof(bool) * 100);  // set whole array to false
    DEBUG(mes.devID);
    
    switch (mes.devID)          // devID indicates device (sensor) type
    {
        case (0):           // uptime
            if (mes.cmd == 1) send0 = true;
        break;
        case (1):           // polling interval in seconds
            if (mes.cmd == 0) {         // cmd == 0 means write a value
                TXinterval = mes.intVal;      // change interval to radio packet value
                if (TXinterval <10 && TXinterval !=0) TXinterval = 10;  // minimum interval is 10 seconds
                if (setAck) send1 = true;     // send message if required
                DEBUG("Setting interval to ");
                DEBUG(TXinterval);
                DEBUGln(" seconds");
            }
            else send1 = true;          // cmd == 1 is a read request, so send polling interval 
            break;
        case (2):             // signal strength
            if (mes.cmd == 1) send2 = true;
            break;
        case (3):             // software version
            if (mes.cmd == 1) send3 = true;
            break;
        case (4):             // battery level
            if (mes.cmd == 1) send4 = true;
            break;
        case (5):             // set ack status
            if (mes.cmd == 0) {
              if (mes.intVal == 0) setAck = false;
              if (mes.intVal == 1) setAck = true;
              if (setAck) send5 = true;     // acknowledge message ?
            }
            else send5 = true;          // read request means schedule a message
            break;
        case (6):             // set toggle
            if (mes.cmd == 0) {
                if (mes.intVal == 0) toggleOnButton = false;
                if (mes.intVal == 1) toggleOnButton = true;
                if (setAck) send6 = true;     // acknowledge message ?
            }
            else send6 = true;
            break;
        case (7):           // timer interval in seconds
            if (mes.cmd == 0) {         // cmd == 0 means write a value
                TIMinterval = mes.intVal;     // change interval 
                if (TIMinterval <5 && TIMinterval !=0) TIMinterval = 5;
                if (setAck) send7 = true;     // acknowledge message ?
            }             // cmd == 1 means read a value
            else send7 = true;          // send timing interval 
            break;
        case (8):           // retransmissions
            if (mes.intVal == 1) send8 = true;
            break;
        case (9):           // retransmissions
            if (mes.cmd == 1) send9 = true;
            break;
        case (16):            // Actuator 1
            if (mes.cmd == 0) {         // cmd == 0 means write
                if(mes.intVal == 0 || mes.intVal == 1) 
                {
                    ACT1State = mes.intVal;
                    //digitalWrite(ACT1, ACT1State);
                    if (setAck) send16 = true;      // acknowledge message ?
                    DEBUG("Set LED to ");
                    DEBUGln(ACT1State);
                }
            }
            else send16 = true;         // cmd == 1 means read
            break;      
        case (40):            // binary input
            if (mes.cmd == 1) send40 = true;
            break;
        case (48):            // temperature
            if (mes.cmd == 1) send48 = true;
            break;
        case (49):            // humidity
            if (mes.cmd == 1) send49 = true;
            break;
        case (50):             // pressure
            if (mes.cmd ==1) send50 = true;
            break;
        case (51):
            if (mes.cmd == 1) send51 = true;
            break;
        case (63):             // Light level in DAC's
            if(mes.cmd == 1) send63 = true;
            break;
        default: send92 = true;         // no valid device parsed
    }
} // end parseCmd


//
//
//======================    SENDMSG: sends messages that are flagged for transmission
//
//----------------------            prepares values to be transmitted
void sendMsg() 
{          
    bool tx = false;          // transmission flag

//    memset(&mes,0,sizeof(mes));
    
    mes.nodeID=node.NODEID;
    mes.intVal = 0;
    mes.fltVal = 0;
    mes.cmd = 0;            // '0' means no action needed in gateway
    int i;
    for ( i = 0; i < sizeof(VERSION); i++){
    mes.payLoad[i] = VERSION[i];  }
    mes.payLoad[i] = '\0';          // software version in payload string
    
    if (wakeUp) {           // send wakeUp call 
        DEBUGln("Wakeup:  ");
        mes.devID = 99; 
        wakeUp = false;         // reset transmission flag for this message
        txRadio();          // transmit
    }
    
    if (send0) {
        mes.devID = 0;
//        mes.intVal = upTime;        // minutes uptime
        send0 = false;
        txRadio();
    }
    if (send1) {            // transmission interval
        mes.devID = 1;
        mes.intVal = TXinterval;      // seconds (integer)
        send1 = false;
        txRadio();
    }
    if (send2) {
        mes.devID = 2;
        mes.intVal = signalStrength;      // signal strength (integer)
        send2 = false;
        txRadio();
    }
    if (send3) {            // node software version (string)
        mes.devID = 3;   
        for ( i = 0; i < sizeof(VERSION); i++) mes.payLoad[i] = VERSION[i];  
        mes.payLoad[i] = '\0';          // software version in payload string
        send3 = false;
        txRadio();
    }
    if (send4) {            // measure voltage..
        mes.devID = 4;  
        mes.fltVal = readBattery();    // Voltage in Volt (float)
        txRadio();
        send4 = false;
    }
    if (send5) {            // Acknowledge on 'SET'
        mes.devID = 5;
        if (setAck) mes.intVal = 1; else mes.intVal = 0;// state (integer)
        send5 = false;
        txRadio();
    }
    if (send6) {            // Toggle on Buttonpress 
        mes.devID = 6;
        if (toggleOnButton) mes.intVal = 1;     // read state of toggle flag
        else mes.intVal = 0;        // state (integer)
        send6 = false;
        txRadio();
    }
    if (send7) {            // timer interval
        mes.devID = 7;
        mes.intVal = TIMinterval;     // seconds (integer)
        send7 = false;
        txRadio();
    }
    if (send8) {
        mes.devID=8;
        mes.intVal = 1;
//        pulseRelay();
        send8 = false;
        txRadio();
    }
    if (send9) {            // number of retransmissions
        mes.devID = 9;
        mes.intVal = numtx;     // number (integer)
        send9 = false;
        txRadio();
    }
    if (send16) {           // state of Actuator 1
        mes.devID = 16;
        mes.intVal = ACT1State;       // state (integer)
        send16 = false;
        txRadio();
    }
    if (send40) {           // Binary input read
        mes.devID = 40;
//        mes.intVal = fPresence;
        if(fPresence)
            mes.intVal = 1;
        else if(!fPresence)
            mes.intVal = 0;
//        if (curState == LOW) mes.intVal = 1;          // state (integer)
        send40 = false;
        txRadio();
    }
    if (send48 || send49 || send50) // Need to re-trigger BME280
         bme.reset_run_mode();
    if (send48) {           // Temperature
        mes.devID = 48;
        float temp = bme.readTempC();
        mes.fltVal = temp* 9/5+32;        // Degrees Fahrenheit (float)
//        mes.fltVal = weatherShield_SI7021.getFahrenheitHundredths()/100.;
        send48 = false;
        txRadio();
    }
    if (send49) {           // Humidity
        mes.devID = 49;
        float hum = bme.readFloatHumidity();
        mes.fltVal = hum;       // Percentage (float)
//        mes.fltVal = weatherShield_SI7021.getHumidityBasisPoints()/100.;
        send49 = false;
        txRadio();
    }
    if (send50) {           // Pressure
        mes.devID = 50;
        float pressure = bme.readFloatPressure()/100.;
        mes.fltVal = pressure;
//        mes.fltVal = getPressure();        // Pressure hPa (float)
        send50 = false;
        txRadio();
    }
    if (send51) {           // Temperature
        mes.devID = 51;
//        temp = bme.readTempC();
//        mes.fltVal = temp* 9/5+32;        // Degrees Fahrenheit (float)
//        sensors.requestTemperatures(); // Send the command to get temperatures
//        mes.fltVal = sensors.getTempCByIndex(0)*9./5.+32.;
        send51 = false;
        txRadio();
    }

    if (send63) {           // Light sensor level in DAC's
        mes.devID = 63;
        mes.fltVal = readLightLevel();
        send63 = false;
        txRadio();
    }
    if (send72) {            // node software version (string)
        mes.devID = 72;          
        //sprintf(mes.payLoad, STATUS==STATUS_CLOSED ? "CLOSED" : STATUS==STATUS_CLOSING ? "CLOSING" : STATUS==STATUS_OPENING ? "OPENING" : STATUS==STATUS_OPEN ? "OPEN" : "UNKNOWN");
        send72 = false;
        txRadio();
    }
    if (send92) {           // error message invalid device
        mes.intVal = mes.devID;
        mes.devID = 92;
        send92 = false;
        txRadio();
    }

}

//
//=======================   TXRADIO
//
//-----------------------       Transmits the 'mes'-struct to the gateway
void txRadio()            
{
    retx = true;
    int i = 0;

//    radio.sendWithRetry(node.GATEWAYID, (const void*)(&mes), sizeof(mes));
//    signalStrength = radio.RSSI;

    DEBUG("Message ");
    DEBUG(mes.devID);
    DEBUG("  ");
    DEBUG(mes.intVal);
    DEBUG("  ");
    DEBUG(mes.fltVal);
    DEBUG("  ");
    DEBUG(mes.payLoad);
    DEBUG(" sent...");
 
    while (retx && i<2) {
        if (radio.sendWithRetry(node.GATEWAYID, (const void*)(&mes), sizeof(mes),5)) {
            retx = false;
            signalStrength = radio.RSSI;
            DEBUG(" RSSI = ");
            DEBUG(signalStrength);
            DEBUG(", Retries = ");
            DEBUGln(i);
        } else delay(500);
        i++;
    }
    numtx = i;              // store number of retransmissions needed
    if (retx) DEBUGln("No connection...");
}  // end txRadio

